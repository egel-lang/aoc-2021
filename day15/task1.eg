# Advent of Code (AoC) - day 15, task 1

import "prelude.eg"
import "os.ego"
import "regex.ego"
import "generator.eg"
import "dictionary.eg"

using System
using OS
using List

def max = [ X Y -> if X < Y then Y else X ]

def print_board = 
    [ B -> let KK = dict_keys B in 
        foldl [(X0,Y0) (X1,Y1) -> (if not (X0 == X1) then print "\n" else none);
               print (dict_get B (X1, Y1)); (X1,Y1) ] (head KK) KK; print "\n" ]

def input = let L = read_line stdin in if eof stdin then nil else cons L input
val digit = Regex::compile "[0-9]"
def parse_line = map to_int . Regex::matches digit   

def risk    = dict_from_list . flatten . Gen::to_lists . Gen::zip_2d Gen::space . Gen::from_lists
def totals  = dict_map [_ -> 0] . dict_copy
def visited = dict_map [_ -> false] . dict_copy

def adjacent = [D (X,Y) -> filter (dict_has D) {(X - 1,Y),(X + 1,Y),(X,Y - 1), (X, Y + 1)}] 
def end = [D -> foldl [(X0,Y0) (X1,Y1) -> (max X0 X1, max Y0 Y1)] (0,0) (dict_keys D)]

def pqput =
    [ (N, V) {} -> {(N,V)}
    | (N, V) {(N0,V0)|PQ} -> if N < N0 then {(N,V),(N0,V0)|PQ} else {(N0,V0)| pqput (N,V) PQ} ]

def dijkstra_run = 
    [ R T V {} -> T
    | R T V {(RISK,P)|PQ} ->
        dict_set V P true;
        let ADJ = filter [P -> not (dict_get V P)] (adjacent R P) in
        let PP = map [P -> (RISK + dict_get R P, P)] ADJ in
        let PQ = foldl [PQ (RISK,P) -> pqput (RISK,P) PQ ] PQ PP in
        foldl [T (RISK,P) -> dict_set T P RISK ] T PP;
            dijkstra_run R T V PQ ]

def dijkstra =
    [ R -> dijkstra_run R (totals R) (dict_set (visited R) (0,0) true) {(0,(0,0))} ]

def main =
    let R = (risk . map parse_line) input in
    let T = dijkstra R in
        dict_get T (end R) - dict_get R (0,0)
