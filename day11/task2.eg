# Advent of Code (AoC) - day 11, task 2

import "os.ego"
import "regex.ego"
import "dictionary.eg"
import "prelude.eg"
import "generator.eg"
using System
using OS
using List

def input = let L = read_line stdin in if eof stdin then nil else cons L input
val digit = Regex::compile "[0-9]"
def parse_line = map to_int . Regex::matches digit   

def to_board = 
   Gen::to_lists . Gen::zip_2d Gen::space . Gen::from_lists

def stencil = dict_from_list . List::flatten

val update_stencil = 
    (stencil . List::map (List::map [((X,Y),V) -> ((X - 1, Y - 1), V)]) . to_board)
    {{1, 1, 1}, {1, -100, 1}, {1, 1, 1}}

def increase_octopi = dict_map ((+) 1)

val flash_counter = ref 0
def flash_get     = get_ref flash_counter
def flash_inc     = set_ref flash_counter (flash_get + 1)
def flash_reset   = set_ref flash_counter 0

def flash_octopus = [ F O -> flash_inc; apply_mask F O ]

def apply_mask =
    [ F (X0, Y0) ->
        foldl
        [ U (X1,Y1) -> 
            let (X2, Y2) = (X0+X1, Y0+Y1) in
            dict_lazy_update F (X2, Y2) [_ -> (dict_get F (X2, Y2)) + (dict_get update_stencil (X1,Y1))] ]
        F
        (dict_keys update_stencil) ]
 
def find_flash =
    [ F -> foldl [O0 O1 -> if 10 <= (dict_get F O1) then O1 else O0] none (dict_keys F) ]

def flash_octopi =
    [ F -> [ none -> F | O -> flash_octopus F O; flash_octopi F ] (find_flash F) ] 

def unflash_octopi =
    [ F -> foldl [F O -> if dict_get F O < 0 then dict_set F O 0 else F ] F (dict_keys F) ]

def next = [ F ->  increase_octopi F; flash_octopi F; unflash_octopi F; F ]

def find = [ F N X -> F X; if 100 <= flash_get then (N+1) else flash_reset; find F (N+1) X ]

def main =
    let LL = map parse_line input in 
    let F = (stencil . to_board) LL in
        find next 0 F
