# Advent of Code (AoC) - day 9, task 2

import "os.ego"
import "regex.ego"
import "dict.ego"
import "prelude.eg"
import "generator.eg"

using System
using OS
using List

def input = let L = read_line stdin in if eof stdin then nil else cons L input
val digit = Regex::compile "[0-9]"
def parse_line = map to_int . Regex::matches digit   

def to_board = 
   List::flatten . Gen::to_lists . Gen::zip_2d Gen::space . Gen::from_lists

def print_board = ## write a generator for this
    [ F (X,Y) (MAXX, MAXY) ->
        if X < MAXX then 
            if Y < MAXY then print (dict_get F (X,Y)); print_board F (X,Y+1) (MAXX, MAXY) 
            else print "\n"; print_board F (X+1,0) (MAXX, MAXY)
        else none ]


def stencil = foldl [D (K,V) -> dict_set D K V] dict

def update_map = ## generate this once
    { ((-1, -1), 1), ((-1, 0), 1), ((-1, 1), 1), 
      ((0,  -1), 1), ((0,  0),-20), ((0 , 1), 1),
      ((1,  -1), 1), ((1,  0), 1), ((1 , 1), 1) }

val update_stencil = stencil update_map

def increase_octopi =
    [ F -> foldl [F (X,Y) -> dict_set F (X,Y) (dict_get F (X,Y) + 1)] F (dict_keys F) ]

val flash_counter = ref 0
def flash_get     = get_ref flash_counter
def flash_inc     = set_ref flash_counter (flash_get + 1)
def flash_reset   = set_ref flash_counter 0

def flash_octopus = [ F O -> flash_inc; apply_mask F O ]

def apply_mask =
    [ F (X0, Y0) ->
        foldl
        [ U (X1,Y1) -> 
            let (X2, Y2) = (X0+X1, Y0+Y1) in
            if dict_has F (X2,Y2) then dict_set F (X2, Y2) ((dict_get F (X2, Y2)) + (dict_get update_stencil (X1,Y1))) else F ]
        F
        (dict_keys update_stencil) ]
 
def find_flash =
    [ F -> foldl [O0 O1 -> if 10 <= (dict_get F O1) then O1 else O0] none (dict_keys F) ]

def flash_octopi =
    [ F -> [ none -> F | O -> flash_octopus F O; flash_octopi F ] (find_flash F) ] 

def unflash_octopi =
    [ F -> foldl [F O -> if dict_get F O < 0 then dict_set F O 0 else F ] F (dict_keys F) ]

def debug = [ F -> print "flash: " flash_get "\n"; print_board F (0,0) (10, 10) ]

def next = [ F ->  increase_octopi F; flash_octopi F; unflash_octopi F; debug F; F ]

def find = [ F N X -> F X; if 100 <= flash_get then (N+1) else flash_reset; find F (N+1) X ]

def main =
    let LL = map parse_line input in 
    let F = (stencil . to_board) LL in
        find next 0 F
